#! /usr/bin/python3.8
import csv
from typing import List


class Solution(object):
    def __init__(self, filename):
        self.filename = filename

    def _process_step(
        self,
        step: List[int],
        states: List[List[int]],
    ) -> int:
        """Turns lights on or off according to step and returns # of lights on.

        Args:
            step: List containing in order: [on/off status, low x bound,
                high x bound, low y bound, high y bound, low z bound, high z
                bound].
            states: List of all intersections of steps and their respective
                on/off status.

        Returns:
            New universe of states generated by current step's intersection
            with all existing states appended to the current universe of
            states.
        """
        on, x_lo, x_hi, y_lo, y_hi, z_lo, z_hi = step
        new_states = []
        if on:
            new_states.append(step)

        for s_on, s_x_lo, s_x_hi, s_y_lo, s_y_hi, s_z_lo, s_z_hi in states:
            # No overlap between current step and current state
            if (
                s_x_hi < x_lo
                or x_hi < s_x_lo
                or s_y_hi < y_lo
                or y_hi < s_y_lo
                or s_z_hi < z_lo
                or z_hi < s_z_lo
            ):
                continue
            # Overlapped segments
            o_x_lo = max(x_lo, s_x_lo)
            o_x_hi = min(x_hi, s_x_hi)
            o_y_lo = max(y_lo, s_y_lo)
            o_y_hi = min(y_hi, s_y_hi)
            o_z_lo = max(z_lo, s_z_lo)
            o_z_hi = min(z_hi, s_z_hi)

            # Covers double-counting when both are on, and turning overlap off
            if s_on == 1:
                new_states.append(
                    [-1, o_x_lo, o_x_hi, o_y_lo, o_y_hi, o_z_lo, o_z_hi]
                )
            # Covers creating new overlap segment whether new state is on/off
            elif s_on == 0:
                new_states.append(
                    [0, o_x_lo, o_x_hi, o_y_lo, o_y_hi, o_z_lo, o_z_hi]
                )
            # Covers turning overlap back on after being turned off
            elif s_on == -1:
                new_states.append(
                    [1, o_x_lo, o_x_hi, o_y_lo, o_y_hi, o_z_lo, o_z_hi]
                )
        for new_state in new_states:
            states.append(new_state)

        return states

    def _on_lights(self, states: List[List[int]]) -> int:
        """Counts number of on lights by simulating states.

        Args:
            states: List of all intersections of steps and their respective
                on/off status.

        Returns:
            Number of lights on after simulating all step intersections.
        """
        lights = 0

        for s_on, s_x_lo, s_x_hi, s_y_lo, s_y_hi, s_z_lo, s_z_hi in states:
            if s_on != 0:
                x_diff = abs(s_x_hi - s_x_lo) + 1
                y_diff = abs(s_y_hi - s_y_lo) + 1
                z_diff = abs(s_z_hi - s_z_lo) + 1
                lights += s_on * x_diff * y_diff * z_diff
        return lights

    def solve(self):
        with open(self.filename) as f:
            csv_reader = csv.reader(f)
            steps = []
            states = []

            for row in csv_reader:
                on_str, x_str = row[0].split(" ")
                on = 1 if on_str == "on" else 0
                x_bound_str = x_str.split("=")[1].split("..")
                x_lo, x_hi = [int(num) for num in x_bound_str]
                y_bound_str = row[1].split("=")[1].split("..")
                y_lo, y_hi = [int(num) for num in y_bound_str]
                z_bound_str = row[2].split("=")[1].split("..")
                z_lo, z_hi = [int(num) for num in z_bound_str]
                step = [on, x_lo, x_hi, y_lo, y_hi, z_lo, z_hi]

                steps.append(step)

            for step in steps:
                states = self._process_step(step, states)

            print(self._on_lights(states))


if __name__ == "__main__":
    sol = Solution("input.csv")
    sol.solve()
